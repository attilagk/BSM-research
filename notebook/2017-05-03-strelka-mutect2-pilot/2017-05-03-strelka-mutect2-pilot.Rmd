---
layout: default
title: 'strelka and mutect2: Determinants of Runtime'
tags: [ strelka, mutect2 ]
featimg: "scaling-length-log-1.png"
---

Rationale: (1) understand determinants of the runtime of variant calling programs mutect2 and stelka; (2) obtain hints for speed-up by parallelization

```{r echo=FALSE, warning=FALSE}
library(lme4)
library(lattice)
#library(latticeExtra)
opts_chunk$set(dpi = 144)
opts_chunk$set(out.width = "700px")
opts_chunk$set(dev = c("png", "pdf"))
lattice.options(default.args = list(as.table = TRUE))
lattice.options(default.theme = "standard.theme")
```

## Experimental setup

### Scripts and data files

```{r}
rdepth <- lapply(tissues <- c("NeuN_pl", "NeuN_mn", "muscle"),
                 function(x) {
                     df <- read.delim(paste0("results/32MB/MSSM179_", x , "-32MB.bam.depth.1000"),
                                      header = FALSE, col.names = c("ones", "pos", "depth"))[-1]
                     df$tissue <- factor(x, levels = tissues, ordered = TRUE)
                     return(df)
                 })
rdepth <- do.call(rbind, rdepth)
runt <- read.csv("results/runtimes.csv")
```

The `*.depth.1000` files were generated by `mydepth.sh`, which calls `samtools depth` and downsamples positions by taking only every 1000th position.

`runtimes.csv` was generated by the `parser.sh` script after running strelka and mutect2 using `docall.sh` on various length alignment-pairs generated by `aln-subregion`.  Each alignment pair corresponds to a genomic segment of certain length and a certain tissue pair (one of `r levels(runt$tissue.pair)`) in individual MSSM179.  Note that the NeuN_pl sample was sequenced at a much higher depth than the muscle or NeuN_mn sample.   All alignments starts at 1:100,000,000 (100 MB of chromosome 1) but end at some position such that the lengths form a sequence of `r unique(runt$seglen / 1e6)` megabases.

### Read depth

The following two plots show the read depth---sampled at every 1000th position with `mydepth.sh`---along the 32MB subregion.  Read depth varies about $$\approx 150$$ for NeuN_pl and $$\approx 30$$ for NeuN_mn and muscle between 100MB and 121.5MB but at 121.5MB it shoots up into a short burst of spikes after which it falls down to 0 and remains there until and over 132MB.

```{r read-depth, echo=FALSE}
xyplot(depth ~ (pos / 1e6)  | tissue, data = rdepth, type = "l", pch = 20, xlab = "position (MB)", grid = TRUE, layout = c(3, 1), xlim = c(99, 133))
```

```{r read-depth-yzoom, echo=FALSE}
xyplot(depth ~ (pos / 1e6)  | tissue, data = rdepth, type = "p", pch = ".", xlab = "position (MB)", grid = TRUE, layout = c(3, 1), xlim = c(99, 133), ylim = c(-10,300), par.settings = list(plot.symbol = list(alpha = 1.0)))
```

The following screenshot from `samtools tview` reveals that after position 1:121485441 the reference sequence is made of `N`s and so explains the rapid fall of read depth to zero seen above.  Note that reads are shown here only up to depth 20.

```
121485381  121485391 121485401  121485411 121485421 121485431 121485441 121485451 121485461 121485471 121485481 121485491 121485501 121485511 121485521 121485531 121485541 121485551 121485561 121485571 121485581 121485591 121485601 121485611
ACCTCCTT*GAGGCCTTCGTTGGAAACGGGATTTCTTC*ATATTCTGCTAGACAGAAGAATTCNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
.....Y.. ............................. .....M..................Y
....  ..*................G....G.......*..................
........*......................
. ......*.............................*.....A..
. ...T..*.............................*........................
. A.....*.....TC......................*.............T..........
. ...T..*.............................*.....G.................
. ......*.............................*.....
. ...T..*.............................*........................
. ...T..*.............................*........................
. ......*T.....C......................*.....A..................
. ...T..*....T............A...........*........................
. A.....*.....T.......................*........
. ...T..*A............................*.............A.........
. ......*.............................*........................
. ......*.............................*.............
. A.....*.....T.......................*.............A.........
. ......*.............................*..G.....
. ......*.............................*....
. ......*.............................*.....A..............
```

## Runtime (serial computing)

### Scaling

This setup allows to study the dependence of caller runtime on

1. the caller (strelka or mutect2)
1. length of genomic segment
1. read depth

The next two graphs convey information on all these points.  In particular it can be concluded that

* strelka runs much faster than mutect2
* for both callers
    * runtime scales linearly with the DNA segment's length
    * runtime is faster at lower depths

The last point follows from the fact that the tissue pair muscle-NeuN_mn corresponds to the two relative low-coverage alignments as well as from the relatively small increase (or no increase at all) of the 32MB runtime relative to the 16MB runtime by recalling that much of the second half of the 32MB segment has zero depth.

```{r scaling-length, echo=FALSE}
arg <- list(xlab = "length (bases)", ylab = "real time",
            labels = c("1s", "7.8s", "1m", "7.8m", "1h", "7.8h", "2.5d", "2.8w", "5m"),
            at.lin = 0:8 / 2, at.log = 60 ^ c(0:8 / 2))
xyplot(real.time ~ seglen | tissue.pair, data = runt, groups = caller, type = "b", xlab = arg$xlab, ylab = paste(arg$ylab, "(s)"), par.settings = list(superpose.line = list(lty = 2)), grid = TRUE, auto.key = list(text = c("mutect2", "strelka")), layout = c(3,1))
```

The following, log-scaled, graph also shows predictions of a linear model fitted to the results using the automatic line fitting facility of the `lattice` package (see `type="r"` and `panel.lmline`).  The right limit of the x axis is at 3GB so the fitted curves predict more than a week of runtime for mutect2 on the whole genome.

```{r scaling-length-log, echo=FALSE}
xyplot(log(real.time, base = 60) ~ log10(seglen) | tissue.pair, data = runt, groups = caller, type = c("p", "r"), xlab = paste("lg", arg$xlab), ylab = paste(arg$ylab, " (log scale)"), grid = TRUE, auto.key = list(text = c("mutect2", "strelka")), xlim = c(5.5, log10(3e9)), ylim = c(1, 3.5), scales = list(y = list(at = arg$at.lin, labels = arg$labels)), layout = c(3,1))
```

### Parallel computing: multithreading

mutect2 is implemented with optional multithreading.  However, the following plot demonstrates that multithreading efficiency for mutect2 is poor.  The poor efficiency of mutect2 is particularly evident when compared to pigz, bwa, or bowtie2 (results for those 3 programs were taken from an earlier analysis; see `~/projects/tests/results/bsub-profiles/`).

```{r echo=FALSE}
mutect2 <- read.csv("results/runtimes-nthreads.csv")
mutect2 <- cbind(data.frame(program = "mutect2"), mutect2)
bwa <- read.csv("~/projects/tests/results/bsub-profiles/aligners/machine-nproc-ptile.csv")
bwa <- cbind(data.frame(program = "bwa"), with(bwa, subset(bwa, subset = machine == "mothra" & size == "medium" & aligner == "bwa" & nproc == ptile, select = c("nproc", "real.time"))))
names(bwa) <- names(mutect2)
bowtie2 <- read.csv("~/projects/tests/results/bsub-profiles/aligners/machine-nproc-ptile.csv")
bowtie2 <- cbind(data.frame(program = "bowtie2"), with(bowtie2, subset(bowtie2, subset = machine == "mothra" & size == "medium" & aligner == "bowtie2" & nproc == ptile, select = c("nproc", "real.time"))))
names(bowtie2) <- names(mutect2)
pigz <- read.csv("~/projects/tests/results/bsub-profiles/pigz/runtimes-pigz-NA.csv")
pigz <- cbind(data.frame(program = "pigz"), with(pigz, subset(pigz, subset = machine == "manda" & size == "large", select = c("ptile", "realtime"))))
names(pigz) <- names(mutect2)
threading <- rbind(mutect2, bwa, bowtie2, pigz)
```

```{r multithreading, echo=FALSE}
xyplot(real.time ~ nthreads | program, data = threading, type = "b", par.settings = list(plot.line = list(lty = 2)), scales = list(y = list(relation = "free")), xlim = c(0.5, 8.5), ylim = list(c(0, 2800), c(0, 1100), c(0, 1100), c(0, 2500)), panel = function(...) { panel.xyplot(...); panel.abline(h=0, lty = "dotted") }, xlab = "threads", ylab = "real time (s)")
```
