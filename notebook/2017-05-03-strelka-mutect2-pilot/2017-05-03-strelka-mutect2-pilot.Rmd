```{r echo=FALSE}
library(lme4)
library(lattice)
#library(latticeExtra)
opts_chunk$set(dpi = 144)
opts_chunk$set(out.width = "700px")
opts_chunk$set(dev = c("png", "pdf"))
lattice.options(default.args = list(as.table = TRUE))
lattice.options(default.theme = "standard.theme")
```

## Scaling with segment length

```{r}
rdepth <- lapply(tissues <- c("NeuN_pl", "NeuN_mn", "muscle"),
                 function(x) {
                     df <- read.delim(paste0("results/16MB/MSSM179_", x , "-16MB.bam.depth.1000"),
                                      header = FALSE, col.names = c("ones", "pos", "depth"))[-1]
                     df$tissue <- factor(x, levels = tissues, ordered = TRUE)
                     return(df)
                 })
#names(rdepth) <- tissues
rdepth <- do.call(rbind, rdepth)
runt <- read.csv("results/runtimes.csv")
```

`runtimes.csv` was generated by the `parser.sh` script after running strelka and mutect2 using `docall.sh` on various length alignment-pairs generated by `aln-subregion`.  Each alignment pair corresponds to a genomic segment of certain length and a certain tissue pair (one of `r levels(runt$tissue.pair)`) in individual MSSM179.  Note that the NeuN_pl sample was sequenced at a much higher depth than the muscle or NeuN_mn sample.   All alignments starts at 1:100,000,000 (100 MB of chromosome 1) but end at some position such that the lengths form a sequence of `r unique(runt$seglen / 1e6)` megabases.  This setup allows to study the dependence of caller runtime on

1. the caller (strelka or mutect2)
1. length of genomic segment
1. read depth

```{r read-depth, echo=FALSE}
xyplot(depth ~ (pos / 1e6)  | tissue, data = rdepth, type = "p", pch = ".", xlab = "position (MB)", grid = TRUE, layout = c(3, 1))
```

```{r scaling-length, echo=FALSE}
arg <- list(xlab = "length (bases)", ylab = "real time",
            labels = c("1s", "7.8s", "1m", "7.8m", "1h", "7.8h", "2.5d", "2.8w", "5m"),
            at.lin = 0:8 / 2, at.log = 60 ^ c(0:8 / 2))
xyplot(real.time ~ seglen | tissue.pair, data = runt, groups = caller, subset = tissue.pair != "NeuN_mn-NeuN_pl", type = "b", xlab = arg$xlab, ylab = paste(arg$ylab, "(s)"), par.settings = list(superpose.line = list(lty = 2)), grid = TRUE, auto.key = list(text = c("mutect2", "strelka")))
```

```{r scaling-length-log, echo=FALSE}
xyplot(log(real.time, base = 60) ~ log10(seglen) | tissue.pair, data = runt, groups = caller, subset = tissue.pair != "NeuN_mn-NeuN_pl", type = c("p", "r"), xlab = paste("lg", arg$xlab), ylab = paste(arg$ylab, " (log scale)"), grid = TRUE, auto.key = list(text = c("mutect2", "strelka")), xlim = c(5.5, log10(3e9)), ylim = c(1, 3.5), scales = list(y = list(at = arg$at.lin, labels = arg$labels)))
```

## Multithreading efficiency

```{r echo=FALSE}
mutect2 <- read.csv("results/runtimes-nthreads.csv")
mutect2 <- cbind(data.frame(program = "mutect2"), mutect2)
bwa <- read.csv("~/projects/tests/results/bsub-profiles/aligners/machine-nproc-ptile.csv")
bwa <- cbind(data.frame(program = "bwa"), with(bwa, subset(bwa, subset = machine == "mothra" & size == "medium" & aligner == "bwa" & nproc == ptile, select = c("nproc", "real.time"))))
names(bwa) <- names(mutect2)
bowtie2 <- read.csv("~/projects/tests/results/bsub-profiles/aligners/machine-nproc-ptile.csv")
bowtie2 <- cbind(data.frame(program = "bowtie2"), with(bowtie2, subset(bowtie2, subset = machine == "mothra" & size == "medium" & aligner == "bowtie2" & nproc == ptile, select = c("nproc", "real.time"))))
names(bowtie2) <- names(mutect2)
pigz <- read.csv("~/projects/tests/results/bsub-profiles/pigz/runtimes-pigz-NA.csv")
pigz <- cbind(data.frame(program = "pigz"), with(pigz, subset(pigz, subset = machine == "manda" & size == "large", select = c("ptile", "realtime"))))
names(pigz) <- names(mutect2)
threading <- rbind(mutect2, bwa, bowtie2, pigz)
```

```{r multithreading, echo=FALSE}
xyplot(real.time ~ nthreads | program, data = threading, type = "b", par.settings = list(plot.line = list(lty = 2)), scales = list(y = list(relation = "free")), xlim = c(0.5, 8.5), ylim = list(c(0, 2800), c(0, 1100), c(0, 1100), c(0, 2500)), panel = function(...) { panel.xyplot(...); panel.abline(h=0, lty = "dotted") }, xlab = "threads", ylab = "real time (s)")
```
