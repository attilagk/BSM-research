
```
## Loading required package: Matrix
```

## Scaling with segment length


```r
rdepth <- lapply(tissues <- c("NeuN_pl", "NeuN_mn", "muscle"),
                 function(x) {
                     df <- read.delim(paste0("results/16MB/MSSM179_", x , "-16MB.bam.depth.1000"),
                                      header = FALSE, col.names = c("ones", "pos", "depth"))[-1]
                     df$tissue <- factor(x, levels = tissues, ordered = TRUE)
                     return(df)
                 })
#names(rdepth) <- tissues
rdepth <- do.call(rbind, rdepth)
runt <- read.csv("results/runtimes.csv")
```

`runtimes.csv` was generated by the `parser.sh` script after running strelka and mutect2 using `docall.sh` on various length alignment-pairs generated by `aln-subregion`.  Each alignment pair corresponds to a genomic segment of certain length and a certain tissue pair (one of muscle-NeuN_mn, muscle-NeuN_pl, NeuN_mn-NeuN_pl) in individual MSSM179.  Note that the NeuN_pl sample was sequenced at a much higher depth than the muscle or NeuN_mn sample.   All alignments starts at 1:100,000,000 (100 MB of chromosome 1) but end at some position such that the lengths form a sequence of 1, 2, 4, 8, 16, 32 megabases.  This setup allows to study the dependence of caller runtime on

1. the caller (strelka or mutect2)
1. length of genomic segment
1. read depth

<img src="figure/read-depth-1.png" title="plot of chunk read-depth" alt="plot of chunk read-depth" width="700px" />

<img src="figure/scaling-length-1.png" title="plot of chunk scaling-length" alt="plot of chunk scaling-length" width="700px" />

<img src="figure/scaling-length-log-1.png" title="plot of chunk scaling-length-log" alt="plot of chunk scaling-length-log" width="700px" />

## Multithreading efficiency



<img src="figure/multithreading-1.png" title="plot of chunk multithreading" alt="plot of chunk multithreading" width="700px" />
